#include <stdlib.h>

#include "tinycols.h"

/**
 * random_color() - Return a random jewel color.
 *
 * @return The picked color.
 */
enum color random_color(void)
{
	return rand() % COLOR_MAX + 1;
}

/**
 * grid_alloc() - Allocate memory for a grid, populating the metadata fields.
 *
 * @param rows: The number of rows for the grid.
 * @param cols: The number of columns for the grid.
 * @return The new grid, or NULL if memory allocation fails.
 */
struct grid *grid_alloc(uint8_t rows, uint8_t cols)
{
	const unsigned int size = rows * cols;
	struct grid *gr = malloc(sizeof *gr + sizeof(gr->cells[0]) * size);

	if (gr == NULL) {
		return NULL;
	}

	gr->cols = cols;
	gr->rows = rows;
	gr->size = size;

	return gr;
}

/**
 * get_cell() - Get the grid cell color at the given row and column.
 *
 * @param gr: The grid to inspect.
 * @param row: The row of the cell.
 * @param col: The column of the cell.
 * @return The color of the given cell.
 */
static inline enum color get_cell(const struct grid *gr, int row, int col)
{
	return gr->cells[(row * gr->cols) + col];
}

/**
 * set_cell() - Set the grid cell color at the given row and column.
 *
 * @param gr: The grid to inspect.
 * @param row: The row of the cell.
 * @param col: The column of the cell.
 * @param clr: The color to set.
 */
static inline void set_cell(struct grid *gr, int row, int col, enum color clr)
{
	gr->cells[(row * gr->cols) + col] = clr;
}

/**
 * grid_init() - Initialize a grid.
 *
 * @param gr: The grid to initialize.
 */
void grid_init(struct grid *gr)
{
	for (int i = 0; i < gr->size; i++) {
		gr->cells[i] = TRANSPARENT;
	}
}

/**
 * calc_score() - Compute the score based on the number of jewels removed.
 *
 * @param jewel_count: The number of jewels that were removed.
 * @return The computed score.
 */
static inline score_t calc_score(unsigned int jewel_count)
{
	return (jewel_count - PIECE_SIZE + 1) * SCORE_PER_PIECE;
}

/**
 * grid_scan() - Scan the grid for jewels to remove and calculate the score.
 *
 * @param gr: The grid to inspect.
 * @param result: A buffer to use to record the results.
 *                This contains markers for the jewels to be removed later.
 *                This buffer must be as big as the grid itself.
 * @return The score based on what was found to be removed.
 */
score_t grid_scan(const struct grid *gr, uint8_t *result)
{
	unsigned int size = gr->size;
	score_t score = 0;

	// Initialize the result to remove any previous information.
	for (int i = 0; i < size; i++) {
		result[i] = 0;
	}

	for (int idx = 0; idx < size; idx++) {
		const uint8_t color = gr->cells[idx];
		if (color != TRANSPARENT) {
			// Horizontal check
			unsigned int count = 1;
			unsigned int lim = ((idx / gr->cols) * gr->cols) + gr->cols;
			for (int i = 1, ldx; (ldx = idx + i) < lim; i++) {
				if (gr->cells[ldx] == color) {
					count++;
				} else break;
			}
			if (count >= PIECE_SIZE) {
				score += calc_score(count);
				for (int i = 0; i < count; i++) {
					result[idx + i] = color;
				}
			}
			// Vertical check
			count = 1;
			for (int i = 1, ldx; (ldx = idx + i * gr->cols) < size; i++) {
				if (gr->cells[ldx] == color) {
					count++;
				} else break;
			}
			if (count >= PIECE_SIZE) {
				score += calc_score(count);
				for (int i = 0; i < count; i++) {
					result[idx + (i * gr->cols)] = color;
				}
			}
			// Diagonal check: left, down
			count = 1;
			for (int i = 1, row = idx / gr->cols; i < size; i++) {
				const int ldx = idx - i + (i * gr->cols);
				if ((ldx / gr->cols == row + i) &&
					ldx < size &&
					(gr->cells[ldx] == color)) {
					count++;
				} else break;
			}
			if (count >= PIECE_SIZE) {
				score += calc_score(count);
				for (int i = 0; i < count; i++) {
					result[idx - i + (i * gr->cols)] = color;
				}
			}
			// Diagonal check: right, down
			count = 1;
			for (int i = 1, row = idx / gr->cols; i < size; i++) {
				const int ldx = idx + i * gr->cols + i;
				if ((ldx / gr->cols == row + i) &&
					ldx < size &&
					(gr->cells[ldx] == color)) {
					count++;
				} else break;
			}
			if (count >= PIECE_SIZE) {
				score += calc_score(count);
				for (int i = 0; i < count; i++) {
					result[idx + i + (i * gr->cols)] = color;
				}
			}
		}
	}

	return score;
}

/**
 * grid_remove_jewels() - Remove jewels from a grid based on a given buffer.
 *
 * @param gr: The grid to process.
 * @param jewels: A buffer containing markers for jewels to remove.
 *                This is generated by `grid_scan()`.
 * @return The number of jewels removed.
 */
uint16_t grid_remove_jewels(struct grid *gr, const uint8_t *jewels)
{
	uint16_t removed = 0;

	for (int i = 0; i < gr->size; i++) {
		if (jewels[i] != TRANSPARENT) {
			gr->cells[i] = TRANSPARENT;
			removed++;
		}
	}

	return removed;
}

/**
 * init_drops() - Initialize an array of drop structs.
 *
 * @param drs: A pointer to an array of drop structs to initialize.
 * @param max_drops: The max number of structs to initialize.
 *                   This must be equal to or less than the length of the
 *                   array.
 */
static inline void init_drops(struct drop *drs, unsigned int max_drops)
{
	for (unsigned int i = 0; i < max_drops; i++) {
		(drs + i)->col = 0;
		(drs + i)->row = 0;
		(drs + i)->n = 0;
		(drs + i)->h = 0;
	}
}

/**
 * grid_detect_drops() - Detect the drops in a given grid
 *
 * @param gr: The grid to inspect.
 * @param drs: An array of drops to populate with information.
 * @param max_drops: The max number of structs to initialize.
 *                   This must be equal to or less than the length of the
 *                   array.
 * @return The number of drops detected.
 */
unsigned int
grid_detect_drops(const struct grid *gr, struct drop *drs,
				  unsigned int max_drops)
{
	int n = 0;
	int n_drops = 0;
	const int cols = gr->cols;
	const int rows = gr->rows;

	init_drops(drs, max_drops);

	for (int i = 0; i < cols; i++) {
		int gap_end = NOT_FOUND;
		int block_end = NOT_FOUND;

		for (int l = 0; l < rows; l++) {
			const int idx = cols * (rows - l) - i - 1;
			const int cell = (gr->cells)[idx];
			if (cell == TRANSPARENT) {
				if (block_end != NOT_FOUND && gap_end != NOT_FOUND) {
					(drs + n)->col = cols - i - 1;
					(drs + n)->row = (idx + cols) / cols;
					(drs + n)->n = (block_end / cols) - (idx / cols);
					(drs + n)->h = (gap_end / cols) - (block_end / cols);
					n++;
					n_drops++;
					gap_end = NOT_FOUND;
					block_end = NOT_FOUND;
				}
				if (gap_end == NOT_FOUND) {
					gap_end = idx;
					block_end = NOT_FOUND;
				}
			} else if (block_end == NOT_FOUND) {
				block_end = idx;
			}
		}

		// Clean up column
		if (block_end != NOT_FOUND && gap_end != NOT_FOUND) {
			(drs + n)->col = cols - i - 1;
			(drs + n)->row = 0; // Always zero, as we are at the top
			(drs + n)->n = block_end / cols + 1;
			(drs + n)->h = (gap_end / cols) - (block_end / cols);
			n++;
			n_drops++;
		}
	}

	return n_drops;
}

/**
 * grid_apply_drops() - Apply gravity to the grid contents using the given
 *                      information, provided by the drops array.
 *
 * @param gr: The grid to modify.
 * @param drs: The drops array buffer containing the information.
 * @param n_drops: The number of drops found.
 *                 Must be less that the number of drops in the above buffer.
 */
void
grid_apply_drops(struct grid *gr, const struct drop *drs, unsigned int n_drops)
{
	for (int i = 0; i < n_drops; i++) {
		const struct drop *dr = drs + i;
		for (int l = dr->n - 1; l >= 0; l--) {
			const int start = (dr->row + l) * gr->cols + dr->col;
			gr->cells[start + dr->h * gr->cols] = gr->cells[start];
			gr->cells[start] = TRANSPARENT;
		}
	}
}

/**
 * piece_randomize() - Randomize the colors of the jewels in a given piece.
 *
 * @param pc: The piece to modify.
 */
void piece_randomize(struct piece *pc)
{
	for (int i = 0; i < PIECE_SIZE; i++) {
		pc->colors[i] = random_color();
	}
}

/**
 * piece_persist() - Persist a piece in the grid according to its coordinates.
 *
 * @param pc: The piece to persist.
 * @param gr: The grid in which the piece will be persisted.
 * @return Was the piece persisted successfully?
 */
bool piece_persist(struct piece *pc, struct grid *gr)
{
	if (pc->col < 0 || pc->row < 0 ||
		pc->col >= gr->cols || pc->row >= gr->rows ||
		pc->col + PIECE_SIZE > gr->rows) {
		return false;
	}

	for (int i = 0; i < PIECE_SIZE; i++) {
		set_cell(gr, pc->row + i, pc->col, pc->colors[i]);
	}

	pc->status = PERSISTED;

	return true;
}

/**
 * piece_rotate() - Rotate the jewels in the piece.
 *
 * @param pc: The piece to modify.
 * @param dir: The direction of the rotation.
 */
void piece_rotate(struct piece *pc, enum direction dir)
{
	int tmp = (pc->colors)[2];
	if (dir == DOWN) {
		(pc->colors)[2] = (pc->colors)[1];
		(pc->colors)[1] = (pc->colors)[0];
		(pc->colors)[0] = tmp;
	} else if (dir == UP) {
		(pc->colors)[2] = (pc->colors)[0];
		(pc->colors)[0] = (pc->colors)[1];
		(pc->colors)[1] = tmp;
	}
}

/**
 * is_blocked() - Is the piece blocked from moving in a given direction?
 *
 * @param pc: The piece to inspect.
 * @param dir: The direction towards a movement is attempted.
 * @param gr: The grid to inspect.
 * @return Is the piece blocked from movement in that direction?
 */
static inline bool
is_blocked(const struct piece *pc, enum direction dir, const struct grid *gr)
{
	int offset = (dir == RIGHT) ? 1 : -1;
	for (int i = 0; i < PIECE_SIZE; i++) {
		int row = pc->row + i;
		if (row >= 0 && get_cell(gr, row, pc->col + offset) != TRANSPARENT) {
			return true;
		}
	}
	return false;
}

/**
 * piece_move_in_grid() - Move a given price in a grid.
 *
 * @param pc: The piece to move.
 * @param dir: The direction towards a movement is attempted.
 * @param gr: The grid to inspect.
 * @return The outcome of the movement
 */
enum result
piece_move_in_grid(struct piece *pc, enum direction dir, const struct grid *gr)
{
	switch (dir) {
		case DOWN: {
			if (pc->row >= gr->rows - PIECE_SIZE) {
				return (pc->status = LANDED);
			} else if (
				get_cell(gr, pc->row + PIECE_SIZE, pc->col) != TRANSPARENT) {
				return (pc->status = LANDED);
			} else if (pc->row < gr->rows - 1) {
				pc->row++;
				return (pc->status = MOVED);
			}
			break;
		}
		case LEFT: {
			if (pc->col <= 0 || is_blocked(pc, LEFT, gr)) {
				break;
			} else {
				pc->col--;
				return (pc->status = MOVED);
			}
			break;
		}
		case RIGHT: {
			if (pc->col >= gr->cols - 1 || is_blocked(pc, RIGHT, gr)) {
				break;
			} else {
				pc->col++;
				return (pc->status = MOVED);
			}
			break;
		}
		default:
			break;
	}

	return (pc->status = BLOCKED);
}

/**
 * grid_position_piece() - Position a piece at the starting coords of a grid.
 *
 * @param gr: The grid to inspect.
 * @param pc: The piece to position.
 * @return Was the piece positioned successfully?
 */
bool grid_position_piece(struct grid *gr, struct piece *pc)
{
	pc->col = gr->cols / 2;
	pc->row = 1 - PIECE_SIZE;
	if (get_cell(gr, pc->row + 1, pc->col) != TRANSPARENT ||
		get_cell(gr, pc->row + 2, pc->col) != TRANSPARENT) {
		return false;
	}

	return true;
}

/**
 * game_alloc() - Allocate memory for a new game.
 *
 * @return The new grid, or NULL if memory allocation fails.
 */
struct game *game_alloc(void)
{
	struct grid *gr = grid_alloc(GRID_DEFAULT_ROWS, GRID_DEFAULT_COLS);
	if (gr == NULL) {
		return NULL;
	}

	struct game *gm = malloc(sizeof *gm);
	if (gm == NULL) {
		return NULL;
	}

	gm->grid = gr;
	return gm;
}

/**
 * game_cycle_piece() - Cycle the current and next pieces in a given game.
 *
 * @param gm: The game to modify.
 */
void game_cycle_piece(struct game *gm)
{
	for (int i = 0; i < PIECE_SIZE; i++) {
		gm->current_piece.colors[i] = gm->next_piece.colors[i];
	}
	piece_randomize(&gm->next_piece);
}

/**
 * game_init() - Initialize a game.
 *
 * @param gm: The game to initialize.
 * @param level: The level at which the game must be started.
 * @param color_max: The maximum color to use for the jewels.
 */
void game_init(struct game *gm, unsigned int level, enum color color_max)
{
	gm->score = 0;
	gm->level = level;
	gm->status = GAME_READY;
	gm->color_max = color_max;

	piece_randomize(&gm->next_piece);
	game_cycle_piece(gm);
	grid_init(gm->grid);
	grid_position_piece(gm->grid, &gm->current_piece);
}

/**
 * game_free() - Free the memory allocated for a game.
 * @param gm: The game to free.
 */
void game_free(struct game *gm)
{
	free(gm->grid);
	free(gm);
}

enum color test_get_cell(const struct grid *gr, int row, int col)
{
	return get_cell(gr, row, col);
}

void test_set_cell(struct grid *gr, int row, int col, enum color clr)
{
	set_cell(gr, row, col, clr);
}
