#include <ncurses.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>

#include "gfx.h"
#include "tinycols.h"

#define TICK_TIME 10000
#define MAX_TIMER 180

WINDOW *win;
uint8_t tmp_res[GRID_DEFAULT_COLS * GRID_DEFAULT_ROWS];
struct drop tmp_drs[GRID_DEFAULT_COLS * GRID_DEFAULT_ROWS];

/**
 * process_keys() - Process any keypress generated by the game player.
 *
 * @param gm: The game.
 */
void process_keys(struct game *gm)
{
	switch (wgetch(win)) {
	case KEY_RIGHT:
		piece_move_in_grid(&gm->current_piece, RIGHT, gm->grid);
		break;
	case KEY_LEFT:
		piece_move_in_grid(&gm->current_piece, LEFT, gm->grid);
		break;
	case KEY_DOWN:
		piece_move_in_grid(&gm->current_piece, DOWN, gm->grid);
		break;
	case KEY_UP:
		piece_rotate(&gm->current_piece, UP);
		break;
	case 'q':
		gm->status = GAME_OVER;
		break;
	default:
		break;
	}

	flushinp();
}

/**
 * game_tick() - Process a single tick of a game.
 *
 * @param gm: The game.
 */
void game_tick(struct game *gm)
{
	score_t tmp_score = 0;

	if (gm->current_piece.status == PERSISTED) {
		gm->jewels_removed += grid_remove_jewels(gm->grid, tmp_res);
		gm->level = get_level_by_jewels(gm->jewels_removed);
		unsigned int count = 0;
		while ((count = grid_detect_drops(gm->grid, tmp_drs,
						  gm->grid->size))) {
			grid_apply_drops(gm->grid, tmp_drs, count);
		}
	}

	// Move the piece down
	if (gm->current_piece.status < LANDED) {
		piece_move_in_grid(&gm->current_piece, DOWN, gm->grid);
	}

	// Persist if landed
	if (gm->current_piece.status == LANDED) {
		if (piece_persist(&gm->current_piece, gm->grid)) {
			gm->current_piece.status = PERSISTED;
		} else {
			gm->status = GAME_OVER;
		}
	}

	// Scan the playing field for matches
	if (gm->current_piece.status == PERSISTED) {
		if ((tmp_score = grid_scan(gm->grid, tmp_res)) > 0) {
			gm->score += tmp_score;
		} else {
			game_cycle_piece(gm);
			grid_position_piece(gm->grid, &gm->current_piece);
			gm->current_piece.status = UNKNOWN;
		}
	}

	gm->last_score = tmp_score;
}

/**
 * Get the tick time based on the level number
 *
 * @param level: The level number
 * @return The tick time number
 */
static uint8_t get_tick_time(unsigned short level)
{
	return (uint8_t)MAX_TIMER / (level + 1);
}

/**
 * run() - Run the game.
 */
static score_t run(enum game_class cls)
{
	win = setup_gfx();

	struct game *gm = game_alloc();
	if (gm == NULL) {
		perror("Out of memory");
		exit(EXIT_FAILURE);
	}
	game_init(gm, GAME_DEFAULT_LEVEL, cls);

	struct timeval time_start, time_end;
	uint8_t timer = 1;
	uint8_t tick_time = get_tick_time(gm->level);
	while (gm->status != GAME_OVER) {
		// Time Start
		gettimeofday(&time_start, NULL);

		// Process input
		if (gm->current_piece.status < LANDED) {
			process_keys(gm);
		}

		// Process game logic
		if (gm->current_piece.status == LANDED || timer > tick_time) {
			game_tick(gm);
			tick_time = get_tick_time(gm->level);
			timer = 1;
		} else {
			timer++;
		}

		// Render game
		draw_frame(gm, 0, 0);
		draw_game(gm, 0, 0);

		if (gm->current_piece.status == PERSISTED) {
			draw_stars(tmp_res, gm->grid, 0, 0);
		} else {
			draw_piece(&gm->current_piece, 1, 1);
		}
		draw_debug(gm, gm->grid->cols * 2 + 2, 6);
		refresh();

		// Time End
		gettimeofday(&time_end, NULL);
		usleep(time_start.tv_usec + TICK_TIME - time_end.tv_usec);
	}

	usleep(1000000);

	score_t final_score = gm->score;
	game_free(gm);
	teardown_gfx(win);
	return final_score;
}

/**
 * init_rand() - Initialize the random number generator
 */
static void init_rand(void)
{
	struct timeval time_now;
	gettimeofday(&time_now, NULL);
	srand((unsigned int)time_now.tv_usec); // NOLINT(cert-msc51-cpp)
}

static void usage(char *prog_name)
{
	fprintf(stderr, "Usage:\n  %s [-c class]\n", prog_name);
	fputs("\n", stderr);
	fputs("Options:\n", stderr);
	fputs("  -h\t\tPrint this help message.\n", stderr);
	fputs("  -c[N]\t\tSelect game class number N: "
	      "1 (Novice), "
	      "2 (Amateur), "
	      "3 (Pro). "
	      "The default is 2.\n",
	      stderr);
}

int main(int argc, char **argv)
{
	init_rand();
	int opt;
	enum game_class cls = CLASS_AMATEUR;

	char *prog_name = argv[0];
	while ((opt = getopt(argc, argv, "c:h")) != -1) {
		switch (opt) {
		case 'h': {
			usage(prog_name);
			exit(EXIT_SUCCESS);
		}
		case 'c': {
			const int num = atoi(optarg);
			if (num >= 1 && num <= 3) {
				cls = (enum game_class)(num + 3);
			} else {
				fprintf(stderr, "Error: class must be between "
						"1 and 3.\n");
				exit(EXIT_FAILURE);
			}
			break;
		}
		default:
			usage(prog_name);
			exit(EXIT_FAILURE);
		}
	}

	printf("Final score: %hu\n", run(cls));
	return 0;
}
